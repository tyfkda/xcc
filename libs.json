{"usr":{"include":{"sys":{"random.h":"#pragma once\n\n#include \"stddef.h\"  // size_t\n#include \"sys/types.h\"  // ssize_t\n\n#define GRND_NONBLOCK (0x0001)\n#define GRND_RANDOM   (0x0002)\n\nssize_t getrandom(void *buf, size_t buflen, unsigned int flags);\n","types.h":"#pragma once\n\ntypedef long ssize_t;\n\ntypedef int pid_t;\ntypedef long off_t;\n"},"assert.h":"#pragma once\n\n#if defined(NDEBUG)\n#define assert(x)  ((void)0)\n\n#elif defined(__APPLE__)\n\nvoid __assert_rtn(const char *, const char *, int, const char *); // __dead2 __cold __disable_tail_calls;\n#define assert(x)  ((x) ? ((void)0) : __assert_rtn(0, __FILE__, __LINE__, #x))\n\n#else\n\nextern void __assert_fail(const char *assertion, const char *fn, int lineno, const char *func);\n#define assert(x)  ((x) ? ((void)0) : __assert_fail(#x, __FILE__, __LINE__, 0))\n\n#endif\n","ctype.h":"#pragma once\n\nint isdigit(int c);\nint isxdigit(int c);\nint isalpha(int c);\nint isalnum(int c);\nint isspace(int c);\n\nint tolower(int c);\nint toupper(int c);\n","errno.h":"#pragma once\n\n#ifdef __APPLE__\nextern int * __error(void);\n#define errno (*__error())\n\n#else\nextern int *__errno_location(void) /*__THROW __attribute__((__const__))*/;\n#define errno (*__errno_location())\n#endif\n\n#define EPERM            1      /* Operation not permitted */\n#define ENOENT           2      /* No such file or directory */\n#define ESRCH            3      /* No such process */\n#define EINTR            4      /* Interrupted system call */\n#define EIO              5      /* I/O error */\n#define ENXIO            6      /* No such device or address */\n#define E2BIG            7      /* Argument list too long */\n#define ENOEXEC          8      /* Exec format error */\n#define EBADF            9      /* Bad file number */\n#define ECHILD          10      /* No child processes */\n#define EAGAIN          11      /* Try again */\n#define ENOMEM          12      /* Out of memory */\n#define EACCES          13      /* Permission denied */\n#define EFAULT          14      /* Bad address */\n#define ENOTBLK         15      /* Block device required */\n#define EBUSY           16      /* Device or resource busy */\n#define EEXIST          17      /* File exists */\n#define EXDEV           18      /* Cross-device link */\n#define ENODEV          19      /* No such device */\n#define ENOTDIR         20      /* Not a directory */\n#define EISDIR          21      /* Is a directory */\n#define EINVAL          22      /* Invalid argument */\n#define ENFILE          23      /* File table overflow */\n#define EMFILE          24      /* Too many open files */\n#define ENOTTY          25      /* Not a typewriter */\n#define ETXTBSY         26      /* Text file busy */\n#define EFBIG           27      /* File too large */\n#define ENOSPC          28      /* No space left on device */\n#define ESPIPE          29      /* Illegal seek */\n#define EROFS           30      /* Read-only file system */\n#define EMLINK          31      /* Too many links */\n#define EPIPE           32      /* Broken pipe */\n#define EDOM            33      /* Math argument out of domain of func */\n#define ERANGE          34      /* Math result not representable */\n","fcntl.h":"#pragma once\n\n#define O_RDONLY  (00)\n#define O_WRONLY  (01)\n#define O_RDWR    (02)\n#define O_CREAT   (0100)\n#define O_EXCL    (0200)\n#define O_TRUNC   (01000)\n#define O_APPEND  (02000)\n\n#define S_IRUSR         (0400)\n#define S_IWUSR         (0200)\n#define S_IXUSR         (0100)\n#define S_IRGRP         (0040)\n#define S_IWGRP         (0020)\n#define S_IXGRP         (0010)\n#define S_IROTH         (0004)\n#define S_IWOTH         (0002)\n#define S_IXOTH         (0001)\n\n#define AT_FDCWD  -100\n\nint open(const char *fn, int flag, ...);\n","inttypes.h":"#pragma once\n\n#define PRIdPTR  \"ld\"\n#define PRIxPTR  \"lx\"\n","libgen.h":"#pragma once\n\nchar *dirname(char *);\nchar *basename(char *);\n","limits.h":"#pragma once\n\n#define CHAR_BIT   (8)  // Number of bits in one char\n\n#define UCHAR_MAX  (255)  // (2^8)-1\n\n#define SHRT_MIN   (-32768)  // -(2^15)\n#define SHRT_MAX   ( 32767)  //  (2^15)-1\n\n#define USHRT_MAX  (65535)  // (2^16)-1\n\n#define INT_MIN    (-2147483648)  // -(2^31)\n#define INT_MAX    ( 2147483647)  //  (2^31)-1\n\n#define UINT_MAX   (4294967295)  // (2^32)-1\n\n#define LLONG_MIN  (-9223372036854775808)  // -(2^63)\n#define LLONG_MAX  ( 9223372036854775807)  //  (2^63)-1\n","math.h":"#pragma once\n\n#ifndef __NO_FLONUM\n#define M_PI      (3.14159265358979323846)\n#define M_E       (2.718281828459045)\n#define NAN       (0.0 / 0.0)\n#define HUGE_VAL  (1.0 / 0.0)\n\ndouble sin(double);\ndouble cos(double);\ndouble tan(double);\ndouble atan(double);\ndouble sqrt(double);\ndouble log(double x);\ndouble exp(double x);\ndouble pow(double base, double x);\ndouble fabs(double);\ndouble floor(double);\ndouble ceil(double x);\ndouble fmod(double x, double m);\ndouble frexp(double x, int *p);\n\nint isfinite(double x);\nint isnan(double x);\nint isinf(double x);\n#endif\n","stdarg.h":"#pragma once\n\n#include \"stdint.h\"\n\n#if !defined(__WASM)\n\n#if defined(__APPLE__) && defined(__aarch64__)\ntypedef void **va_list;\n\n#define va_start(ap,p)    __builtin_va_start(ap,&(p))\n#define va_end(ap)        /*(void)*/(ap = 0)\n#define va_arg(ap, type)  (*(type*)(ap)++)  // Assume little endian\n#define va_copy(dst,src)  (dst = src)\n\n#else  // not __APPLE__ nor __aarch64__\n\nstruct __va_elem {\n  unsigned int gp_offset;\n  unsigned int fp_offset;\n  void *overflow_arg_area;\n  void *reg_save_area;\n};\n\ntypedef struct __va_elem __builtin_va_list[1];\n\ntypedef __builtin_va_list __gnuc_va_list;\ntypedef __gnuc_va_list va_list;\n\n#define va_start(ap,p)    __builtin_va_start(ap,&(p))\n#define va_end(ap)        __builtin_va_end(ap)\n#define va_arg(ap,ty)     __builtin_va_arg(ap,ty)\n#define va_copy(dst,src)  __builtin_va_copy(dst,src)\n\n#if defined(__aarch64__)\n#define __GP_REG_ARGS  (8)\n#else\n#define __GP_REG_ARGS  (6)\n#endif\n#define __FP_REG_ARGS  (8)\n#define __WORD_SIZE    (8)\n#define __DBL_SIZE     (8)\n\n#define __GP_OFFSET_MAX  (__GP_REG_ARGS * __WORD_SIZE)\n#define __FP_OFFSET_MAX  (__GP_OFFSET_MAX + __FP_REG_ARGS * __DBL_SIZE)\n\n//\n\n#define __va_arg_mem(ap, sz, align) ({ \\\n  uintptr_t p = (uintptr_t)((ap)->overflow_arg_area); \\\n  if ((align) > 8)  p = (p + 15) / 16 * 16; \\\n  (ap)->overflow_arg_area = (void*)((p + (sz) + 7) & -8); \\\n  (char*)p; })\n\n#define __va_arg_gp(ap, sz, align) \\\n  ((ap)->gp_offset < __GP_OFFSET_MAX \\\n    ? (char*)(ap)->reg_save_area + ((ap)->gp_offset += __WORD_SIZE) - __WORD_SIZE \\\n    : __va_arg_mem(ap, sz, align))\n\n#define __va_arg_fp(ap, sz, align) \\\n  ((ap)->fp_offset < __FP_OFFSET_MAX \\\n    ? (char*)(ap)->reg_save_area + ((ap)->fp_offset += __DBL_SIZE) - __DBL_SIZE \\\n    : __va_arg_mem(ap, sz, align))\n\n#ifndef __NO_FLONUM\n#define __builtin_va_arg_fp_case(ap, ty) \\\n  case /*flonum*/ 6: \\\n    p = __va_arg_fp(ap, sizeof(ty), _Alignof(ty)); break;\n#else\n#define __builtin_va_arg_fp_case(ap, ty)  /*none*/\n#endif\n\n#define __builtin_va_arg(ap, ty) ({ \\\n  char *p; \\\n  switch (__builtin_type_kind(ty)) { \\\n  __builtin_va_arg_fp_case(ap, ty) \\\n  case /*fixnum*/ 1: case /*ptr*/ 2: \\\n    p = __va_arg_gp(ap, sizeof(ty), _Alignof(ty)); break; \\\n  default: \\\n    p = __va_arg_mem(ap, sizeof(ty), _Alignof(ty)); break; \\\n  } \\\n  *(ty *)p; })\n\n#define __builtin_va_copy(dest, src) ((dest)[0] = (src)[0])\n\n#define __builtin_va_end(ap)  /* none */\n\n#endif\n\n#else  // __WASM\n\ntypedef __builtin_va_list __gnuc_va_list;\ntypedef __gnuc_va_list va_list;\n\n#define va_start(ap,p)    __builtin_va_start(ap,p)\n#define va_end(ap)        __builtin_va_end(ap)\n#define va_arg(ap,ty)     __builtin_va_arg(ap,ty)\n#define va_copy(dst,src)  __builtin_va_copy(dst,src)\n\n#endif\n","stdbool.h":"#pragma once\n\ntypedef int bool;\n#define false  (0)\n#define true   (1)\n","stddef.h":"#pragma once\n\n#ifndef NULL\n#define NULL  ((void*)0)\n#endif\n\n#define offsetof(S, mem)  ((size_t)&(((S *)0)->mem))\n\ntypedef unsigned long size_t;\ntypedef long ptrdiff_t;\n","stdint.h":"#pragma once\n\n#include \"stddef.h\"\n\n#if defined(__ILP32__)\ntypedef char       int8_t;\ntypedef short      int16_t;\ntypedef int        int32_t;\ntypedef long long  int64_t;\n\ntypedef unsigned char       uint8_t;\ntypedef unsigned short      uint16_t;\ntypedef unsigned int        uint32_t;\ntypedef unsigned long long  uint64_t;\n\ntypedef int32_t  intptr_t;\ntypedef uint32_t uintptr_t;\n#else\ntypedef char  int8_t;\ntypedef short int16_t;\ntypedef int   int32_t;\ntypedef long  int64_t;\n\ntypedef unsigned char  uint8_t;\ntypedef unsigned short uint16_t;\ntypedef unsigned int   uint32_t;\ntypedef unsigned long  uint64_t;\n\ntypedef int64_t  intptr_t;\ntypedef uint64_t uintptr_t;\n#endif\n\n#define INTPTR_MAX  ((((intptr_t)1) << (sizeof(intptr_t) * 8 - 1)) - 1)\n#define INTPTR_MIN  (((intptr_t)-1) << (sizeof(intptr_t) * 8 - 1))\n","stdio.h":"#pragma once\n\n#include \"stdarg.h\"\n#include \"stddef.h\"\n#include \"sys/types.h\"  // ssize_t\n\n#define EOF  (-1)\n\nenum {\n  SEEK_SET,  // 0\n  SEEK_CUR,  // 1\n  SEEK_END,  // 2\n};\n\ntypedef struct FILE FILE;\n\n#ifdef __APPLE__\nextern FILE *__stdinp;\nextern FILE *__stdoutp;\nextern FILE *__stderrp;\n#define stdin   __stdinp\n#define stdout  __stdoutp\n#define stderr  __stderrp\n#else\nextern FILE *stdin;\nextern FILE *stdout;\nextern FILE *stderr;\n#endif\n\nFILE *fopen(const char *fileName, const char *mode);\nFILE *fdopen(int fd, const char *mode);\nint fclose(FILE *fp);\nsize_t fwrite(const void *buffer, size_t size, size_t count, FILE *fp);\nsize_t fread(void *buffer, size_t size, size_t count, FILE *fp);\nint fflush(FILE *fp);\nint fseek(FILE *fp, long offset, int origin);\nlong ftell(FILE *fp);\nint remove(const char *fn);\n\nint fgetc(FILE *fp);\nint fputc(int c, FILE *fp);\nchar *fgets(char *s, int n, FILE *fp);\nint fputs(const char *s, FILE *fp);\nint getc(FILE *fp);\nint getchar(void);\nint puts(const char *s);\n\nint fprintf(FILE *fp, const char *fmt, ...);\nint printf(const char *fmt, ...);\nint sprintf(char *out, const char *fmt, ...);\nint snprintf(char *, size_t n, const char *, ...);\nint vprintf(const char *fmt, va_list ap);\nint vsprintf(char *buf, const char *fmt, va_list ap);\nint vfprintf(FILE *fp, const char *fmt, va_list ap);\nint vsnprintf(char *out, size_t n, const char *fmt_, va_list ap);\n\nvoid perror(const char *);\n\nint fileno(FILE *fp);\nFILE *tmpfile(void);\n\nssize_t getline(char **lineptr, size_t *n, FILE *stream);\n","stdlib.h":"#pragma once\n\n#include \"stddef.h\"  // size_t\n\nint atoi(const char* s);\nvoid *malloc(size_t size);\nvoid free(void* ptr);\nvoid *realloc(void* ptr, size_t size);\nvoid *calloc(size_t size, size_t n);\n\nvoid exit(int code);\n\nlong strtol(const char *p, char **pp, int base);\nunsigned long strtoul(const char *p, char **pp, int base);\n\nvoid qsort(void *base, size_t nmemb, size_t size, int (*compare)(const void *, const void *));\n\n#ifndef __NO_FLONUM\ndouble strtod(const char* /*restrict*/ p, char ** /*restrict*/ pp);\ndouble drand48(void);\ndouble erand48(unsigned short xsubi[3]);\n#endif\n\nint mkstemp(char *template);\nint mkstemps(char *template, int suffixlen);\n","string.h":"#pragma once\n\n#include <stddef.h>  // size_t\n\nsize_t strlen(const char *s);\nchar* strchr(const char *s, int c);\nchar* strrchr(const char *s, int c);\nchar *strstr(const char *s1, const char *s2);\nint strcmp(const char *p, const char *q);\nint strncmp(const char *p, const char *q, size_t n);\nchar* strcpy(char *dst, const char *src);\nchar* strncpy(char *dst, const char *src, size_t n);\nchar *strcat(char *dst, const char *src);\nchar *strncat(char *dst, const char *src, size_t n);\n\nchar *strdup(const char *str);\nchar *strndup(const char *str, size_t size);\n\nvoid* memcpy(void *dst, const void *src, size_t n);\nvoid* memmove(void* dst, const void* src, size_t);\nvoid* memset(void* buf, int val, size_t size);\nvoid *memchr(const void *buf, int c, size_t n);\nint memcmp(const void *buf1, const void *buf2, size_t n);\n","strings.h":"#pragma once\n\n#include <stddef.h>  // size_t\n\nint strcasecmp(const char *p, const char *q);\nint strncasecmp(const char *p, const char *q, size_t n);\n","unistd.h":"#pragma once\n\n#include \"stddef.h\"  // size_t\n#include \"stdint.h\"  // intptr_t\n#include \"sys/types.h\"  // ssize_t, pid_t, off_t\n\n#define STDIN_FILENO   (0)\n#define STDOUT_FILENO  (1)\n#define STDERR_FILENO  (2)\n\nssize_t write(int fd, const void *str, size_t len);\nint close(int fd);\nssize_t read(int fd, void *buf, size_t size);\n\nchar *getcwd(char *buffer, size_t size);\n\npid_t fork(void);\nint pipe(int *);\nint dup(int);\nint execvp(const char *, char *const[]);\nint execve(const char *, char *const[], char *const[]);\noff_t lseek(int fd, off_t offset, int whence);\nint unlink(const char *pathname);\n\nint brk(void *addr);\nvoid *sbrk(intptr_t increment);\n\nint isatty(int fd);\n"},"lib":{"_file.h":"#pragma once\n\nstruct FILE {\n  int fd;\n};\n","_malloc.h":"#pragma once\n\ntypedef long Align;\n\ntypedef union header {\n  struct {\n    union header *ptr;\n    unsigned int size;\n  } s;\n  Align x;\n} Header;\n","crt0.c":"#include <stdlib.h>  // malloc\n\nextern int args_sizes_get(int *pargc, int *plen);\nextern int args_get(char **pargv, char *pstr);\n\nint _start(void) {\n  extern int main(int, char**);\n  int argc, len = 0;\n  int r = args_sizes_get(&argc, &len);\n  if (r != 0)\n    return(r);\n\n  char **argv = malloc(sizeof(char*) * (argc + 1) + len);\n  char *str = ((char*)argv) + sizeof(char*) * (argc + 1);\n  args_get(argv, str);\n  argv[argc] = NULL;\n\n  int ec = main(argc, argv);\n  return ec;\n}\n","libc.c":"#include \"libgen.h\"\n#include \"string.h\"  // strrchr\n\nchar *basename(char *path) {\n  char *p = strrchr(path, '/');\n  if (p != NULL)\n    return p + 1;\n  else\n    return path;\n}\n\n#include \"libgen.h\"\n#include \"string.h\"  // strrchr\n\nchar *dirname(char *path) {\n  char *p = strrchr(path, '/');\n  if (p != NULL) {\n    *p = '\\0';\n    return path;\n  }\n  return \".\";\n}\n\nint *__errno_location(void) {\n  static int value;\n  return &value;\n}\n\n#include \"ctype.h\"\n\nint isalnum(int c) {\n  return isalpha(c) || isdigit(c);\n}\n\n#include \"ctype.h\"\n\nint isalpha(int c) {\n  return ('A' <= c && c <= 'Z') || ('a' <= c && c <= 'z');\n}\n\n#include \"ctype.h\"\n\nint isdigit(int c) {\n  return '0' <= c && c <= '9';\n}\n\n#include \"ctype.h\"\n\nint isspace(int c) {\n  return (c == ' ' || c == '\\t' || c == '\\n' || c == '\\r' ||\n          c == '\\f' || c == '\\v');\n}\n\n#include \"ctype.h\"\n\nint isxdigit(int c) {\n  return ('0' <= c && c <= '9') || ('A' <= c && c <= 'F') || ('a' <= c && c <= 'f');\n}\n\n#if !defined(__WASM)\n#include \"setjmp.h\"\n#include \"assert.h\"\n\nvoid longjmp(jmp_buf env, int result) {\n#if defined(__x86_64__)\n  __asm(\"mov 0(%rdi), %rax\\n\"  // return address.\n        \"mov 8(%rdi), %rbp\\n\"\n        \"mov 16(%rdi), %rsp\\n\"\n        \"mov 24(%rdi), %rbx\\n\"\n        \"mov 32(%rdi), %r12\\n\"\n        \"mov 40(%rdi), %r13\\n\"\n        \"mov 48(%rdi), %r14\\n\"\n        \"mov 56(%rdi), %r15\\n\"\n        \"movsd 64(%rdi), %xmm0\\n\"\n        \"movsd 72(%rdi), %xmm1\\n\"\n        \"movsd 80(%rdi), %xmm2\\n\"\n        \"movsd 88(%rdi), %xmm3\\n\"\n        \"movsd 96(%rdi), %xmm4\\n\"\n        \"movsd 104(%rdi), %xmm5\\n\"\n        \"movsd 112(%rdi), %xmm6\\n\"\n        \"movsd 120(%rdi), %xmm7\\n\"\n        \"mov %rax, (%rsp)\\n\"  // Store return address onto top of the stack.\n        \"mov %esi, %eax\\n\"  // Result value.\n        \"test %eax, %eax\\n\"\n        \"jne .longjmp_0\\n\"\n        \"mov $1, %eax\\n\"\n        \".longjmp_0:\");\n#elif defined(__aarch64__)\n  __asm(\"ldp fp, lr, [x0]\\n\"\n        \"ldp x9, x19, [x0, 16]\\n\"\n        \"ldp x20, x21, [x0, 32]\\n\"\n        \"ldp x22, x23, [x0, 48]\\n\"\n        \"ldp x24, x25, [x0, 64]\\n\"\n        \"ldp x26, x27, [x0, 80]\\n\"\n        \"ldp x28, x29, [x0, 96]\\n\"\n        \"ldp d8, d9, [x0, 112]\\n\"\n        \"ldp d10, d11, [x0, 128]\\n\"\n        \"ldp d12, d13, [x0, 144]\\n\"\n        \"ldp d14, d15, [x0, 160]\\n\"\n        \"mov sp, x9\\n\"\n        \"mov w0, w1\\n\"  // Result value.\n        \"cmp w0, wzr\\n\"\n        \"b.ne .longjmp_0\\n\"\n        \"mov w0, #1\\n\"\n        \".longjmp_0:\");\n#else\n  assert(!\"TODO: Implement\");\n#endif\n}\n#endif\n\n#if !defined(__WASM)\n#include \"stdint.h\"\n#include \"stdbool.h\"\n#include \"sys/random.h\"\n\nuint32_t xor64(void) {\n  static uint64_t seed = 88172645463325252ULL;\n  static bool initialized;\n  if (!initialized) {\n    initialized = getrandom(&seed, sizeof(seed), 0) == sizeof(seed);\n  }\n\n  uint64_t x = seed;\n  x ^= x << 13;\n  x ^= x >> 7;\n  x ^= x << 17;\n  seed = x;\n  return x;\n}\n#endif\n\n#if !defined(__WASM)\n#include \"setjmp.h\"\n#include \"assert.h\"\n\nint setjmp(jmp_buf env) {\n#if defined(__x86_64__)\n  __asm(\"mov (%rsp), %rax\\n\"  // return address.\n        \"mov %rax, 0(%rdi)\\n\"\n        \"mov %rbp, 8(%rdi)\\n\"\n        \"mov %rsp, 16(%rdi)\\n\"\n        \"mov %rbx, 24(%rdi)\\n\"\n        \"mov %r12, 32(%rdi)\\n\"\n        \"mov %r13, 40(%rdi)\\n\"\n        \"mov %r14, 48(%rdi)\\n\"\n        \"mov %r15, 56(%rdi)\\n\"\n        \"movsd %xmm0, 64(%rdi)\\n\"\n        \"movsd %xmm1, 72(%rdi)\\n\"\n        \"movsd %xmm2, 80(%rdi)\\n\"\n        \"movsd %xmm3, 88(%rdi)\\n\"\n        \"movsd %xmm4, 96(%rdi)\\n\"\n        \"movsd %xmm5, 104(%rdi)\\n\"\n        \"movsd %xmm6, 112(%rdi)\\n\"\n        \"movsd %xmm7, 120(%rdi)\\n\"\n        \"xor %eax, %eax\");\n#elif defined(__aarch64__)\n  __asm(\"stp fp, lr, [x0]\\n\"\n        \"mov x9, sp\\n\"\n        \"stp x9, x19, [x0, 16]\\n\"\n        \"stp x20, x21, [x0, 32]\\n\"\n        \"stp x22, x23, [x0, 48]\\n\"\n        \"stp x24, x25, [x0, 64]\\n\"\n        \"stp x26, x27, [x0, 80]\\n\"\n        \"stp x28, x29, [x0, 96]\\n\"\n        \"stp d8, d9, [x0, 112]\\n\"\n        \"stp d10, d11, [x0, 128]\\n\"\n        \"stp d12, d13, [x0, 144]\\n\"\n        \"stp d14, d15, [x0, 160]\\n\"\n        \"mov w0, wzr\");\n#else\n  assert(!\"TODO: Implement\");\n#endif\n}\n#endif\n\n#include \"ctype.h\"\n\nint tolower(int c) {\n  return ('A' <= c && c <= 'Z') ? c + ('a' - 'A') : c;\n}\n\n#include \"ctype.h\"\n\nint toupper(int c) {\n  return ('a' <= c && c <= 'z') ? c - ('a' - 'A') : c;\n}\n\n#include \"assert.h\"\n#include \"stdio.h\"\n#include \"stdlib.h\"\n\nvoid __assert_fail(const char *assertion, const char *fn, int lineno, const char *func) {\n  fprintf(stderr, \"%s:%d: Assertion `%s` failed\\n\", fn, lineno, assertion);\n  exit(1);\n}\n\n#include \"stdio.h\"\n#include \"stdlib.h\"  // free\n#include \"unistd.h\"  // close\n\n#include \"_file.h\"\n\nint fclose(FILE *fp) {\n  if (fp == NULL || fp->fd < 0)\n    return EOF;\n  close(fp->fd);\n  fp->fd = -1;\n  free(fp);\n  return 0;\n}\n\n#include \"stdio.h\"\n#include \"stdlib.h\"  // malloc\n\n#include \"_file.h\"\n\nFILE *fdopen(int fd, const char *mode) {\n  // TODO: Validate fd and mode.\n\n  FILE *fp = malloc(sizeof(*fp));\n  if (fp != NULL) {\n    fp->fd = fd;\n  }\n  return fp;\n}\n\n#include \"stdio.h\"\n\nint fflush(FILE *fp) {\n  // No data are buffered currently.\n  return 0;\n}\n\n#include \"stdio.h\"\n#include \"unistd.h\"  // read\n\n#include \"./_file.h\"\n\nint fgetc(FILE *fp) {\n  unsigned char c;\n  int len = read(fp->fd, &c, 1);\n  return len == 1 ? c : EOF;\n}\n\n#include \"stdio.h\"\n\nchar *fgets(char *s, int n, FILE *fp) {\n  --n;\n  char *p = s;\n  for (int i = 0; i < n; ++i) {\n    int c = fgetc(fp);\n    if (c == EOF)\n      break;\n    *p++ = c;\n    if (c == '\\n')\n      break;\n  }\n  if (p == s)\n    return NULL;\n  *p = '\\0';\n  return s;\n}\n\n#include \"stdio.h\"\n\n#include \"./_file.h\"\n\nint fileno(FILE *fp) {\n  return fp->fd;\n}\n\n#include \"stdio.h\"\n#include \"fcntl.h\"  // open\n#include \"stdlib.h\"  // malloc\n#include \"string.h\"  // strcmp\n#include \"unistd.h\"  // close\n\n#include \"_file.h\"\n\nFILE *fopen(const char *fileName, const char *mode) {\n  static const struct {\n    const char *str;\n    int flag;\n  } kTable[] = {\n    {\"r\", O_RDONLY},\n    {\"w\", O_WRONLY | O_CREAT | O_TRUNC},\n    {\"a\", O_WRONLY | O_CREAT | O_APPEND},\n    {\"rb\", O_RDONLY},\n    {\"wb\", O_WRONLY | O_CREAT | O_TRUNC},\n    {\"ab\", O_WRONLY | O_CREAT | O_APPEND},\n    {\"r+\", O_RDONLY},\n    {\"w+\", O_WRONLY | O_CREAT},\n    {\"a+\", O_WRONLY | O_CREAT | O_APPEND},\n    {\"r+b\", O_RDONLY},\n    {\"w+b\", O_WRONLY | O_CREAT},\n    {\"a+b\", O_WRONLY | O_CREAT | O_APPEND},\n    {\"rb+\", O_RDONLY},\n    {\"wb+\", O_WRONLY | O_CREAT},\n    {\"ab+\", O_WRONLY | O_CREAT | O_APPEND},\n  };\n\n  int flag = -1;\n  for (int i = 0; i < sizeof(kTable) / sizeof(*kTable); ++i) {\n    if (strcmp(kTable[i].str, mode) == 0) {\n      flag = kTable[i].flag;\n      break;\n    }\n  }\n  FILE *fp = NULL;\n  if (flag != -1) {\n    const int mod = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH;\n    int fd = open(fileName, flag, mod);\n    if (fd >= 0) {\n      fp = fdopen(fd, mode);\n      if (fp == NULL) {\n        close(fd);\n      }\n    }\n  }\n  return fp;\n}\n\n#include \"stdio.h\"\n\nint fprintf(FILE *fp, const char *fmt, ...) {\n  va_list ap;\n  va_start(ap, fmt);\n  int len = vfprintf(fp, fmt, ap);\n  va_end(ap);\n  return len;\n}\n\n#include \"stdio.h\"\n#include \"unistd.h\"  // read\n\n#include \"./_file.h\"\n\nint fputc(int c, FILE *fp) {\n  unsigned char cc = c;\n  int len = write(fp->fd, &cc, 1);\n  return len == 1 ? c : EOF;\n}\n\n#include \"stdio.h\"\n#include \"string.h\"\n\nint fputs(const char *s, FILE *fp) {\n  return fwrite(s, strlen(s), 1, fp) == 1 ? 1 : EOF;\n}\n\n#include \"stdio.h\"\n#include \"unistd.h\"  // read\n\n#include \"./_file.h\"\n\nsize_t fread(void *buffer, size_t size, size_t count, FILE *fp) {\n  ssize_t readed = read(fp->fd, buffer, size * count);\n  if (readed == -1)\n    return 0;\n  return (size_t)readed / size;\n}\n\n#include \"stdio.h\"\n#include \"unistd.h\"  // read\n\n#include \"./_file.h\"\n\nint fseek(FILE *fp, long offset, int origin) {\n  off_t result = lseek(fp->fd, offset, origin);\n  if (result == -1)\n    return 1;  // TODO:\n  return 0;\n}\n\n#include \"stdio.h\"\n#include \"unistd.h\"  // read\n\n#include \"./_file.h\"\n\nlong ftell(FILE *fp) {\n  return lseek(fp->fd, 0, SEEK_CUR);\n}\n\n#include \"stdio.h\"\n#include \"unistd.h\"  // write\n\n#include \"./_file.h\"\n\nsize_t fwrite(const void *buffer, size_t size, size_t count, FILE *fp) {\n  return write(fp->fd, buffer, size * count);\n}\n\n#include \"stdio.h\"\n\nint getc(FILE *fp) {\n  return fgetc(fp);\n}\n\n#include \"stdio.h\"\n\nint getchar(void) {\n  return fgetc(stdin);\n}\n\n#include \"stdio.h\"\n#include \"stdlib.h\"  // realloc\n\nssize_t getline(char **lineptr, size_t *pcapa, FILE *stream) {\n  const int MIN_CAPA = 16;\n  ssize_t capa = *pcapa;\n  ssize_t size = 0;\n  char *top = *lineptr;\n  if (top == NULL || capa <= 0) {\n    top = NULL;\n    capa = 0;\n  }\n  for (;;) {\n    int c = fgetc(stream);\n    if (c == EOF) {\n      if (size == 0)\n        return -1;\n      break;\n    }\n\n    if (size + 1 >= capa) {\n      ssize_t newcapa = capa * 2;\n      if (newcapa < MIN_CAPA)\n        newcapa = MIN_CAPA;\n      char *reallocated = realloc(top, newcapa);\n      if (reallocated == NULL) {\n        *lineptr = top;\n        *pcapa = capa;\n        return -1;\n      }\n      top = reallocated;\n      capa = newcapa;\n    }\n\n    //assert(size < capa);\n    top[size++] = c;\n\n    if (c == '\\n')\n      break;\n  }\n\n  //assert(size < capa);\n  top[size] = '\\0';\n  *lineptr = top;\n  *pcapa = capa;\n  return size;\n}\n\n#include \"stdio.h\"\n\nvoid perror(const char *msg) {\n  fprintf(stderr, \"perror: %s\\n\", msg);\n}\n\n#include \"stdio.h\"\n#include \"stdarg.h\"\n\nint printf(const char *fmt, ...) {\n  va_list ap;\n  va_start(ap, fmt);\n  int len = vfprintf(stdout, fmt, ap);\n  va_end(ap);\n  return len;\n}\n\n#include \"stdio.h\"\n\nint puts(const char *s) {\n  printf(\"%s\\n\", s);\n  return 0;\n}\n\n#include \"stdio.h\"\n#include \"unistd.h\"\n\nint remove(const char *fn) {\n  return unlink(fn);\n}\n\n#include \"stdio.h\"\n\nint snprintf(char *out, size_t n, const char *fmt, ...) {\n  va_list ap;\n  int len;\n  va_start(ap, fmt);\n  len = vsnprintf(out, n, fmt, ap);\n  va_end(ap);\n  return len;\n}\n\n#include \"stdio.h\"\n#include \"stdarg.h\"\n\nint sprintf(char *out, const char *fmt, ...) {\n  va_list ap;\n  int len;\n  va_start(ap, fmt);\n  len = vsnprintf(out, (size_t)-1, fmt, ap);\n  va_end(ap);\n  return len;\n}\n\n#include \"stdio.h\"\n#include \"unistd.h\"\n\n#include \"_file.h\"\n\nstatic FILE _stdin = {.fd = STDIN_FILENO};\nstatic FILE _stdout = {.fd = STDOUT_FILENO};\nstatic FILE _stderr = {.fd = STDERR_FILENO};\nFILE *stdin = &_stdin;\nFILE *stdout = &_stdout;\nFILE *stderr = &_stderr;\n\n#include \"stdio.h\"\n\n#if defined(__WASM)\nextern int _tmpfile(void);\n#else\n#include \"stdlib.h\"  // mkstemp\n#include \"unistd.h\"  // close\n#endif\n\nFILE *tmpfile(void) {\n#if defined(__WASM)\n  int fd = _tmpfile();\n#else\n  char template[] = \"/tmp/tmpXXXXXX\";\n  int fd = mkstemp(template);\n#endif\n  FILE *fp = NULL;\n  if (fd >= 0) {\n    fp = fdopen(fd, \"w+\");\n    if (fp == NULL) {\n      close(fd);\n    }\n  }\n  return fp;\n}\n\n#include \"stdio.h\"\n#include \"unistd.h\"\n\nint vfprintf(FILE *fp, const char *fmt, va_list ap) {\n  // TODO: directly output to fd, not use vsnprintf.\n  char buf[1024];\n  int len = vsnprintf(buf, sizeof(buf), fmt, ap);\n  return write(fileno(fp), buf, len);\n}\n\n#include \"stdio.h\"\n\nint vprintf(const char *fmt, va_list ap) {\n  return vfprintf(stdout, fmt, ap);\n}\n\n#include \"ctype.h\"\n#include \"stdarg.h\"\n#include \"stdint.h\"  // uintptr_t\n#include \"stdio.h\"\n#include \"string.h\"\n\n#define NULL  ((void*)0)\n#define MIN(a, b)  ((a) < (b) ? (a) : (b))\n\nstatic char kHexDigits[] = \"0123456789abcdef\";\nstatic char kUpperHexDigits[] = \"0123456789ABCDEF\";\n\n#ifndef __NO_FLONUM\nstatic double pow10(int order) {\n  double a = 1, x = 10;\n  for (; order > 0; order >>= 1) {\n    if ((order & 1) != 0)\n      a *= x;\n    x *= x;\n  }\n  return a;\n}\n#endif\n\nstatic int\nputnstr(char *out, int o, int n, const char *s)\n{\n  while (*s != '\\0' && o < n)\n    out[o++] = *s++;\n  return o;\n}\n\nstatic int\nputpadding(char *out, int o, int n, int m, char padding)\n{\n  if (m > n - o)\n    m = n - o;\n  for (; m > 0; --m)\n    out[o++] = padding;\n  return o;\n}\n\n// Output is not '\\0' terminated.\nstatic int\nsnprintuint(char *out, unsigned int n, unsigned int x,\n            int base, const char* digits, int order, int padding)\n{\n  char buf[16];\n  unsigned int i, o;\n\n  i = 0;\n  do{\n    buf[i++] = digits[x % base];\n    x /= base;\n  }while(x != 0);\n\n  if (i < order) {\n    memset(buf + i, padding, order - i);\n    i = order;\n  }\n\n  for (o = 0; i > 0 && o < n; ++o)\n    out[o] = buf[--i];\n\n  return o;\n}\n\nstatic int\nsnprintulong(char *out, unsigned int n, unsigned long x,\n             int base, const char* digits, int order, int padding)\n{\n  char buf[32];\n  unsigned int i, o;\n\n  i = 0;\n  do{\n    buf[i++] = digits[x % base];\n    x /= base;\n  }while(x != 0);\n\n  if (i < order) {\n    memset(buf + i, padding, order - i);\n    i = order;\n  }\n\n  for (o = 0; i > 0 && o < n; ++o)\n    out[o] = buf[--i];\n\n  return o;\n}\n\nstatic int\nsnprintstr(char *out, unsigned int n, const char* s,\n           int order, int suborder, int leftalign)\n{\n  int o = 0;\n  if(s == NULL)\n    s = \"(null)\";\n  size_t len = strlen(s);\n  if (suborder > 0)\n    len = MIN(len, suborder);\n  if (order <= 0 || len >= order) {\n    o = putnstr(out, o, MIN(n, o + len), s);\n  } else {\n    if (leftalign) {\n      o = putnstr(out, o, MIN(n, o + len), s);\n      o = putpadding(out, o, n, order - len, ' ');\n    } else {\n      o = putpadding(out, o, n, order - len, ' ');\n      o = putnstr(out, o, MIN(n, o + len), s);\n    }\n  }\n  return o;\n}\n\nstatic int\nsprintsign(char *out, int negative, int force, int *porder)\n{\n  int o = 0;\n  if (negative) {\n    out[o++] = '-';\n  } else if (force) {\n    out[o++] = '+';\n  }\n  if (*porder > 1 && o > 0)\n    *porder -= o;\n  return o;\n}\n\n// Only understands %d, %x, %X, %p, %s, %c, %f and \"+-0~9\".\n// '\\0' is not put at the end if the buffer is smaller than output.\nint\nvsnprintf(char *out, size_t n, const char *fmt_, va_list ap)\n{\n  const unsigned char *fmt = (const unsigned char*)fmt_;\n  int c, i;\n  int o;\n\n  for(i = o = 0; fmt[i] != '\\0' && o < n; i++){\n    c = fmt[i];\n    if(c != '%'){\n      out[o++] = c;\n      continue;\n    }\n\n    // Handle '%'\n    char padding = ' ';\n    int order = 0, suborder = 0;\n    int sign = 0;\n    int leftalign = 0;\n    int bLong = 0;\n    c = fmt[++i];\n    if (c == '+') {\n      sign = 1;\n      c = fmt[++i];\n    } else if (c == '-') {\n      leftalign = 1;\n      c = fmt[++i];\n    }\n    if (c == '0') {\n      padding = '0';\n      c = fmt[++i];\n    }\n    if (c >= '1' && c <= '9') {\n      order = c - '0';\n      while (c = fmt[++i], c >= '0' && c <= '9')\n        order = order * 10 + (c - '0');\n    } else if (c == '*') {\n      order = va_arg(ap, int);\n    }\n    if (c == '.') {\n      c = fmt[++i];\n      if (isdigit(c)) {\n        do {\n          suborder = suborder * 10 + (c - '0');\n        } while (isdigit(c = fmt[++i]));\n      } else if (c == '*') {\n        suborder = va_arg(ap, int);\n        c = fmt[++i];\n      }\n    }\n\n    if(c == 'l'){\n      bLong = 1;\n      c = fmt[++i];\n    }\n    if(c == 'd'){\n      if (bLong) {\n        long x = va_arg(ap, long);\n        o += sprintsign(out + o, x < 0, sign, &order);\n        unsigned long ux = x < 0 ? -x : x;\n        o += snprintulong(out + o, n - o, ux, 10, kHexDigits, order, padding);\n      } else {\n        int x = va_arg(ap, int);\n        o += sprintsign(out + o, x < 0, sign, &order);\n        unsigned int ux = x < 0 ? -x : x;\n        o += snprintuint(out + o, n - o, ux, 10, kHexDigits, order, padding);\n      }\n    } else if(tolower(c) == 'x') {\n      const char *digits = c == 'x' ? kHexDigits : kUpperHexDigits;\n      if (bLong) {\n        long x = va_arg(ap, long);\n        o += snprintulong(out + o, n - o, x, 16, digits, order, padding);\n      } else {\n        int x = va_arg(ap, int);\n        o += snprintuint(out + o, n - o, x, 16, digits, order, padding);\n      }\n    } else if(c == 'p') {\n      void *ptr = va_arg(ap, void*);\n      order -= 2;\n      if (order < 0)\n        order = 0;\n      if (order == 0 || padding != ' ') {\n        o += snprintstr(out + o, n - o, \"0x\", 0, 0, 0);\n        o += snprintulong(out + o, n - o, (uintptr_t)ptr, 16, kHexDigits, order, padding);\n      } else {\n        char buf[32];\n        int oo = snprintulong(buf, sizeof(buf), (uintptr_t)ptr, 16, kHexDigits, 0, padding);\n        if (order > oo)\n          o = putpadding(out, o, n, order - oo, padding);\n        o += snprintstr(out + o, n - o, \"0x\", 0, 0, 0);\n        o += snprintstr(out + o, n - o, buf, 0, 0, 0);\n      }\n    } else if(c == 's'){\n      // (\"%5\", \"foo\")         = \"  foo\"\n      // (\"%-5\", \"foo\")        = \"foo  \"\n      // (\"%5\", \"foobarbaz\")   = \"foobarbaz\"\n      // (\"%.3\", \"foobarbaz\")  = \"foo\"\n      // (\"%5.7\", \"foobarbaz\") = \"foobarb\"\n      // (\"%5.3\", \"foobarbaz\") = \"  foo\"\n\n      const char *s = va_arg(ap, const char*);\n      o += snprintstr(out + o, n - o, s, order, suborder, leftalign);\n    } else if(c == 'c'){\n      out[o++] = va_arg(ap, unsigned int);\n    } else if(c == '%'){\n      out[o++] = c;\n#ifndef __NO_FLONUM\n    } else if(c == 'f'){\n      double x = va_arg(ap, double);\n\n      o += sprintsign(out + o, x < 0, sign, &order);\n      x = x < 0 ? -x : x;\n\n      long intPart = x >= 0 ? (long)x : -(long)(-x);\n      o += snprintulong(out + o, n - o, intPart, 10, kHexDigits,\n                        order, padding);\n      if (o < n) {\n        out[o++] = '.';\n        suborder = suborder > 0 ? suborder : 6;\n        unsigned long fraction = (unsigned long)((x - intPart) * pow10(suborder));\n        o += snprintulong(out + o, n - o, fraction, 10, kHexDigits,\n                          suborder, '0');\n      }\n#endif\n    } else {\n      // Unknown % sequence.  Print it to draw attention.\n      out[o++] = '%';\n      if (o >= n)\n        break;\n      if (c != '\\0')\n        out[o++] = c;\n    }\n  }\n\n  if (o < n)\n    out[o] = '\\0';\n  return o;\n}\n\n#include \"stdio.h\"\n\nint vsprintf(char *buf, const char *fmt, va_list ap) {\n  return vsnprintf(buf, -1UL, fmt, ap);\n}\n\n#include \"stdlib.h\"\n\nint atoi(const char *s) {\n  int n = 0;\n  for (; '0' <= *s && *s <= '9'; ++s)\n    n = n * 10 + (*s - '0');\n  return n;\n}\n\n#include \"stdlib.h\"\n#include \"string.h\"  // memset\n\nvoid *calloc(size_t nmemb, size_t size) {\n  size_t nbytes = nmemb * size;\n  void *adr = malloc(nbytes);\n  if (adr != NULL)\n    memset(adr, 0, nbytes);\n  return adr;\n}\n\n#include \"stdlib.h\"\n\n#ifndef __NO_FLONUM\ndouble drand48(void) {\n  // TODO: Implement\n  static unsigned int x = 1;\n  static const unsigned int A = 214013;\n  static const unsigned int C = 2531011;\n  x = x * A + C;\n  return (x >> 16) / 65535.0;\n}\n#endif\n\n#include \"stdlib.h\"\n\n#ifndef __NO_FLONUM\ndouble erand48(unsigned short xsubi[3]) {\n  // TODO: Implement\n  return drand48();\n}\n#endif\n\n#include \"stdlib.h\"\n\n#if defined(__XV6)\nvoid exit(int code) {\n  __asm(\"mov $2, %eax\\n\"  // SYS_exit\n        \"int $64\");\n}\n\n#elif defined(__WASM)\n\n#elif defined(__linux__)\n#include \"../unistd/_syscall.h\"\n\nvoid exit(int code) {\n#ifdef __NR_exit_group\n  SYSCALL(__NR_exit_group);\n#endif\n  SYSCALL(__NR_exit);\n}\n\n#elif defined(__APPLE__)\n\n// Use libc.\n\nextern void exit(int code);\n\n#else\n#error Target not supported\n#endif\n\n#include \"_malloc.h\"\n#include \"stdlib.h\"\n#include \"unistd.h\"  // for sbrk\n\n// Memory allocator by Kernighan and Ritchie,\n// The C programming Language, 2nd ed.  Section 8.7.\n\n#define PAGESIZE  (4096)\n\nstatic Header base = {.s={.ptr=&base, .size=0}};\nstatic Header *freep = &base;\n\nvoid free(void *ap) {\n  Header *bp, *p;\n\n  if (ap == 0)\n    return;\n\n  bp = (Header*)ap - 1;\n  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)\n    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))\n      break;\n  if(bp + bp->s.size == p->s.ptr){\n    bp->s.size += p->s.ptr->s.size;\n    bp->s.ptr = p->s.ptr->s.ptr;\n  } else\n    bp->s.ptr = p->s.ptr;\n  if(p + p->s.size == bp){\n    p->s.size += bp->s.size;\n    p->s.ptr = bp->s.ptr;\n  } else\n    p->s.ptr = bp;\n  freep = p;\n}\n\nstatic Header *morecore(size_t nu) {\n  size_t size;\n  char *p;\n  Header *hp;\n\n  size = (nu * sizeof(Header) + (PAGESIZE - 1)) & -PAGESIZE;\n  p = sbrk(size);\n  if(p == (char*)-1)\n    return 0;\n  hp = (Header*)p;\n  hp->s.size = size / sizeof(Header);\n  free((void*)(hp + 1));\n  return freep;\n}\n\nvoid *malloc(size_t nbytes) {\n  Header *p, *prevp;\n  size_t nunits;\n\n  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;\n  prevp = freep;\n  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){\n    if(p->s.size >= nunits){\n      if(p->s.size == nunits)\n        prevp->s.ptr = p->s.ptr;\n      else {\n        p->s.size -= nunits;\n        p += p->s.size;\n        p->s.size = nunits;\n      }\n      freep = prevp;\n      return (void*)(p + 1);\n    }\n    if(p == freep)\n      if((p = morecore(nunits)) == 0)\n        return 0;\n  }\n}\n\n#if !defined(__WASM)\n#include \"stdlib.h\"\n\nint mkstemp(char *template) {\n  return mkstemps(template, 0);\n}\n#endif\n\n#if !defined(__WASM)\n#include \"stdlib.h\"\n#include \"errno.h\"\n#include \"fcntl.h\"  // open\n#include \"stdint.h\"  // uint32_t\n#include \"string.h\"  // strlen\n\nextern uint32_t xor64(void);\n\nint mkstemps(char *template, int suffixlen) {\n#define LETTERS (10 + 26 + 26)\n  static const char kLetters[LETTERS] = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n  const int LEN = 6;\n  const uint32_t RNDMAX = ((1UL << 32) / LETTERS) * LETTERS;\n\n  size_t len = strlen(template);\n  if (len < LEN + suffixlen) {\n    errno = EINVAL;\n    return -1;\n  }\n  char *p = &template[len - suffixlen - LEN];\n  for (int j = 0; j < LEN; ++j) {\n    if (*p != 'X') {\n      errno = EINVAL;\n      return -1;\n    }\n    uint32_t r;\n    do {\n      r = xor64();\n    } while (r >= RNDMAX);\n    *p++ = kLetters[r % LETTERS];\n  }\n\n  return open(template, O_RDWR | O_CREAT | O_EXCL, S_IRUSR | S_IWUSR);\n#undef LETTERS\n}\n#endif\n\n#include \"stdlib.h\"\n\nvoid qsort(void *base, size_t nmemb, size_t size, int (*compare)(const void *, const void *)) {\n  if (nmemb <= 1)\n    return;\n\n  char *a = base;\n\n  size_t mid = nmemb >> 1;\n  const char *px = &a[mid * size];\n  size_t i = 0;\n  size_t j = nmemb - 1;\n  for (;;) {\n    while (i < mid && compare(&a[i * size], px) < 0)\n      ++i;\n    while (j > mid && compare(px, &a[j * size]) < 0)\n      --j;\n    if (i >= j)\n      break;\n\n    char *pi = &a[i * size];\n    char *pj = &a[j * size];\n    for (size_t k = 0; k < size; ++k) {\n      char t = pi[k];\n      pi[k] = pj[k];\n      pj[k] = t;\n    }\n    if (px == pi) {\n      px = pj;\n      mid = j;\n      ++i;\n    } else if (px == pj) {\n      px = pi;\n      mid = i;\n      --j;\n    } else {\n      ++i;\n      --j;\n    }\n  }\n  if (i > 1)\n    qsort(a, i, size, compare);\n  if ((size_t)(j + 2) < nmemb)\n    qsort(&a[(j + 1) * size], nmemb - j - 1, size, compare);\n}\n\n#include \"_malloc.h\"\n#include \"stdlib.h\"\n#include \"string.h\"  // memcpy\n\nvoid *realloc(void* p, size_t size) {\n  if (size <= 0) {\n    free(p);\n    return NULL;\n  }\n\n  if (p == NULL)\n    return malloc(size);\n\n  void* buf = malloc(size);\n  if (buf != NULL) {\n    Header* h = (Header*)p - 1;\n    size_t s = (h->s.size - 1) * sizeof(Header);\n    memcpy(buf, p, size > s ? s : size);\n    free(p);\n  }\n  return buf;\n}\n\n#include \"stdlib.h\"\n#include \"stdbool.h\"\n#include \"string.h\"\n\nbool parse_sign(const char **pp);\n\n#ifndef __NO_FLONUM\nstatic double ipow(double base, long x) {\n  bool neg = false;\n  if (x < 0) {\n    neg = true;\n    x = -x;\n  }\n  double result = 1;\n  double a = base;\n  for (; x > 0; x >>= 1, a *= a) {\n    if ((x & 1) != 0)\n      result *= a;\n  }\n  return neg ? 1.0 / result : result;\n}\n\nstatic double strtod_i(const char *p, const char **pp) {\n  double result = 0;\n  for (;; ++p) {\n    char c = *p;\n    if (!(c >= '0' && c <= '9'))\n      break;\n    result = result * 10 + (c - '0');\n  }\n  *pp = p;\n  return result;\n}\n\ndouble strtod(const char* /*restrict*/ p, char ** /*restrict*/ pp) {\n  const char *orig = p;\n  bool neg = parse_sign(&p);\n\n  static const struct {\n    const char *str;\n    double pos, neg;\n  } CONST[] = {\n    {\"infinity\", 1.0 / 0.0, -1.0 / 0.0},\n    {\"inf\", 1.0 / 0.0, -1.0 / 0.0},\n    {\"nan\", 0.0 / 0.0, 0.0 / 0.0},\n  };\n  for (int i = 0, n = sizeof(CONST) / sizeof(*CONST); i < n; ++i) {\n    const char *str = CONST[i].str;\n    size_t len = strlen(str);\n    if (strncmp(p, str, len) == 0) {\n      p += len;\n      char c = *p;\n      if (pp != 0)\n        *pp = (char*)p;\n      return neg ? CONST[i].neg : CONST[i].pos;\n    }\n  }\n\n  const char *op = p;\n  double result = strtod_i(p, &p);\n  if (*p == '.') {\n    const char *q = p + 1;\n    double frac = strtod_i(q, &p);\n    result += frac * ipow(10, q - p);\n  }\n  if (*p == 'e' || *p == 'E') {\n    const char *q = p + 1;\n    bool neg2 = parse_sign(&q);\n    double order = strtod_i(q, &p);\n    if (q == p) {\n      // Error.\n    } else {\n      result *= ipow(10, neg2 ? -order : order);\n    }\n  }\n  if (p == op)\n    p = orig;\n  if (neg)\n    result = -result;\n\n  if (pp != 0)\n    *pp = (char*)p;\n\n  return result;\n}\n#endif\n\n#include \"stdlib.h\"\n#include \"ctype.h\"  // tolower\n#include \"stdbool.h\"\n\nbool parse_sign(const char **pp) {\n  const char *p = *pp;\n  char c = *p;\n  bool negative = c == '-';\n  if (c == '+' || c == '-')\n    *pp = p + 1;\n  return negative;\n}\n\nunsigned long strtoul_sub(const char *p, char **pp, int base) {\n  char digimax = '0' + (base <= 10 ? base : 10);\n  char hexmax = 'a' - 10 + base;\n  unsigned long result = 0;\n  for (;; ++p) {\n    char c = *p;\n    int n;\n    if ('0' <= c && c < digimax)\n      n = c - '0';\n    else {\n      c = tolower(c);\n      if ('a' <= c && c < hexmax)\n        n = c - 'a' + 10;\n      else\n        break;\n    }\n    result = result * base + n;\n  }\n\n  if (pp != 0)\n    *pp = (char*)p;\n\n  return result;\n}\n\nlong strtol(const char *p, char **pp, int base) {\n  const char *orig = p;\n  bool neg = parse_sign(&p);\n  char *q;\n  long result = strtoul_sub(p, &q, base);\n  if (q == p)\n    q = (char*)orig;\n  if (neg)\n    result = -result;\n\n  if (pp != 0)\n    *pp = q;\n\n  return result;\n}\n\n#include \"stdlib.h\"\n\nextern unsigned long strtoul_sub(const char *p, char **pp, int base);\n\nunsigned long strtoul(const char *p, char **pp, int base) {\n  const char *orig = p;\n  if (*p == '+')\n    ++p;\n  char *q;\n  unsigned long result = strtoul_sub(p, &q, base);\n  if (q == p)\n    q = (char*)orig;\n\n  if (pp != 0)\n    *pp = q;\n\n  return result;\n}\n\n#include \"string.h\"\n\nvoid *memchr(const void *buf, int c, size_t n) {\n  for (const char *p = buf, *e = p + n; p < e; ++p) {\n    if (*p == c)\n      return p;\n  }\n  return NULL;\n}\n\n#include \"string.h\"\n\nint memcmp(const void *buf1, const void *buf2, size_t n) {\n  const unsigned char *p = buf1;\n  const unsigned char *q = buf2;\n  int d;\n  for (size_t i = 0; i < n; ++i, ++p, ++q) {\n    d = (int)*(unsigned char*)p - (int)*(unsigned char*)q;\n    if (d != 0)\n      break;\n  }\n  return d;\n}\n\n#include \"string.h\"\n\nvoid *memcpy(void *dst, const void *src, size_t n) {\n  const char *s = src;\n  char *d = dst;\n  while (n-- > 0)\n    *d++ = *s++;\n  return dst;\n}\n\n#include \"string.h\"\n\nvoid *memmove(void *dst, const void *src, size_t n) {\n  const char *s = src;\n  char *d = dst;\n  if (s < d && s + n > d) {\n    s += n;\n    d += n;\n    while (n-- > 0)\n      *--d = *--s;\n  } else {\n    while (n-- > 0)\n      *d++ = *s++;\n  }\n  return dst;\n}\n\n#include \"string.h\"\n\nvoid *memset(void *buf, int val, size_t size) {\n  unsigned char *p = buf;\n  unsigned char v = val;\n  for (size_t i = 0; i < size; ++i)\n    *p++ = v;\n  return buf;\n}\n\n#include \"string.h\"\n#include \"ctype.h\"  // tolower\n\nint strcasecmp(const char *p, const char *q) {\n  for (;; ++p, ++q) {\n    unsigned char c1 = *(unsigned char*)p;\n    unsigned char c2 = *(unsigned char*)q;\n    int d = (int)c1 - (int)c2;\n    if (d != 0)\n      return d;\n    if (c1 == 0)\n      break;\n  }\n  return 0;\n}\n\n#include \"string.h\"\n\nchar *strcat(char *dst, const char *src) {\n  strcpy(dst + strlen(dst), src);\n  return dst;\n}\n\n#include \"string.h\"\n\nchar *strchr(const char *s, int c) {\n  for (; *s != '\\0'; ++s)\n    if (*s == c)\n      return (char*)s;\n  return 0;\n}\n\n#include \"string.h\"\n\nint strcmp(const char *p, const char *q) {\n  while (*p != '\\0' && *p == *q) {\n    ++p;\n    ++q;\n  }\n  return (int)*(unsigned char*)p - (int)*(unsigned char*)q;\n}\n\n#include \"string.h\"\n\nchar *strcpy(char *dst, const char *src) {\n  char *os = dst;\n  while ((*dst++ = *src++) != '\\0')\n    ;\n  return os;\n}\n\n#include \"string.h\"\n#include \"stdlib.h\"  // malloc\n\nchar *strdup(const char *str) {\n  return strndup(str, strlen(str));\n}\n\n#include \"string.h\"\n\nsize_t strlen(const char *s) {\n  const char *p;\n  for (p = s; *p != '\\0'; ++p)\n    ;\n  return p - s;\n}\n\n#include \"string.h\"\n#include \"ctype.h\"  // tolower\n\nint strncasecmp(const char *p, const char *q, size_t n) {\n  for (; n > 0; --n, ++p, ++q) {\n    int c1 = tolower(*(unsigned char*)p);\n    int c2 = tolower(*(unsigned char*)q);\n    int d = c1 - c2;\n    if (d != 0)\n      return d;\n    if (c1 == 0)\n      break;\n  }\n  return 0;\n}\n\n#include \"string.h\"\n\nchar *strncat(char *dst, const char *src, size_t n) {\n  char *os = dst;\n  dst += strlen(dst);\n  for (; n > 0 && *src != '\\0'; --n)\n    *dst++ = *src++;\n  *dst = '\\0';\n  return os;\n}\n\n#include \"string.h\"\n\nint strncmp(const char *p, const char *q, size_t n) {\n  while (n > 0 && *p == *q && *p != '\\0')\n    n--, p++, q++;\n  return n == 0 ? 0 : (int)*(unsigned char*)p - (int)*(unsigned char*)q;\n}\n\n#include \"string.h\"\n\nchar *strncpy(char *dst, const char *src, size_t n) {\n  char *os = dst;\n  for (; n > 0 && (*dst++ = *src++) != '\\0'; --n)\n    ;\n  return os;\n}\n\n#include \"string.h\"\n#include \"stdlib.h\"  // malloc\n\nchar *strndup(const char *str, size_t size) {\n  char *dup = malloc(size + 1);\n  memcpy(dup, str, size);\n  dup[size] = '\\0';\n  return dup;\n}\n\n#include \"string.h\"\n\nchar *strrchr(const char *s, int c) {\n  char *last = NULL;\n  for(; *s != '\\0'; ++s)\n    if(*s == c)\n      last = (char*)s;\n  return last;\n}\n\n#include \"string.h\"\n\nchar *strstr(const char *s1, const char *s2) {\n  for  (size_t len = strlen(s2); *s1 != '\\0'; ++s1) {\n    if (strncmp(s1, s2, len) == 0)\n      return (char*)s1;\n  }\n  return NULL;\n}\n\n#include \"unistd.h\"\n#include \"stdio.h\"  // EOF\n\n#if !defined(__XV6)\n#if defined(__WASM)\nextern size_t __memoryPageCount;\nextern char *__curbrk;\n#define CURBRK  __curbrk\n\n#define HEAP_ALIGN  (8)\n#define MEMORY_PAGE_BIT  (16)\n\nstatic void _growTo(void *ptr) {\n  size_t page = (((size_t)ptr) + ((1 << MEMORY_PAGE_BIT) - 1)) >> MEMORY_PAGE_BIT;\n  if (page > __memoryPageCount) {\n    const size_t grow = page - __memoryPageCount;\n    __builtin_memory_grow(grow);\n    __memoryPageCount += grow;\n  }\n}\n\nint brk(void *addr) {\n  if (addr <= __curbrk)\n    return EOF;\n  void *p = (void*)((((intptr_t)addr) + (HEAP_ALIGN - 1)) & -HEAP_ALIGN);\n  __curbrk = p;\n  _growTo(p);\n  return 0;\n}\n#else\n\n#if defined(__linux__)\n#include \"_syscall.h\"\n\nstatic void *_brk(void *addr) {\n  void *ret;\n  SYSCALL_RET(__NR_brk, ret);\n  return ret;\n}\n#endif\n\nstatic char *curbrk;\n#define CURBRK  curbrk\n\nint brk(void *addr) {\n  void *result = _brk(addr);\n  curbrk = result;\n  return result < addr ? EOF : 0;\n}\n#endif\n\nvoid *sbrk(intptr_t increment) {\n  char *p = CURBRK;\n  if (p == NULL) {\n    if (brk(NULL) < 0)\n      return (void*)-1;\n    p = CURBRK;\n  }\n  char *next = p + increment;\n  if (brk(next) < 0)\n    return (void*)-1;\n  return p;\n}\n#endif\n\n#if !defined(__WASM)\n#include \"unistd.h\"\n#include \"_syscall.h\"\n#include \"fcntl.h\"\n#include \"assert.h\"\n\n#if defined(__aarch64__)\nint fchmodat(int dirfd, const char *pathname, /*mode_t*/int mode, int flags) {\n  int ret;\n  SYSCALL_RET(__NR_fchmodat, ret);\n  return ret;\n}\n#endif\n\nint chmod(const char *pathname, /*mode_t*/int mode) {\n#if defined(__NR_chmod)\n  int ret;\n  SYSCALL_RET(__NR_chmod, ret);\n  return ret;\n#elif defined(__NR_fchmodat)\n  return fchmodat(AT_FDCWD, pathname, mode, 0);\n#else\n  assert(!\"TODO\");\n#endif\n}\n#endif\n\n#if !defined(__WASM)\n#include \"unistd.h\"\n#include \"_syscall.h\"\n\nint close(int fd) {\n  int ret;\n  SYSCALL_RET(__NR_close, ret);\n  return ret;\n}\n#endif\n\n#if !defined(__WASM)\n#include \"unistd.h\"\n#include \"_syscall.h\"\n\nint dup(int fd) {\n  int ret;\n  SYSCALL_RET(__NR_dup, ret);\n  return ret;\n}\n#endif\n\n#if !defined(__WASM)\n#include \"unistd.h\"\n#include \"_syscall.h\"\n\nint execve(const char *path, char *const args[], char *const envp[]) {\n  int ret;\n  SYSCALL_RET(__NR_execve, ret);\n  return ret;\n}\n#endif\n\n#if !defined(__WASM)\n#include \"unistd.h\"\n\nextern char **environ;\n\nint execvp(const char *path, char *const args[]) {\n  return execve(path, args, environ);\n}\n#endif\n\n#if !defined(__WASM)\n#include \"unistd.h\"\n#include \"_syscall.h\"\n#include \"assert.h\"\n\n#if defined(__NR_clone3)\n#include \"signal.h\"\n#include \"stdint.h\"\ntypedef uint64_t u64;\n\nstruct clone_args {\n  u64 flags;        /* Flags bit mask */\n  u64 pidfd;        /* Where to store PID file descriptor\n                       (int *) */\n  u64 child_tid;    /* Where to store child TID,\n                       in child's memory (pid_t *) */\n  u64 parent_tid;   /* Where to store child TID,\n                       in parent's memory (pid_t *) */\n  u64 exit_signal;  /* Signal to deliver to parent on\n                       child termination */\n  u64 stack;        /* Pointer to lowest byte of stack */\n  u64 stack_size;   /* Size of stack */\n  u64 tls;          /* Location of new TLS */\n  u64 set_tid;      /* Pointer to a pid_t array\n                       (since Linux 5.5) */\n  u64 set_tid_size; /* Number of elements in set_tid\n                       (since Linux 5.5) */\n  u64 cgroup;       /* File descriptor for target cgroup\n                       of child (since Linux 5.7) */\n};\n\nstatic long _clone3(struct clone_args *cl_args, size_t size) {\n  long ret;\n  SYSCALL_RET(__NR_clone3, ret);\n  return ret;\n}\n#endif\n\npid_t fork(void) {\n#if defined(__NR_fork)\n  pid_t ret;\n  SYSCALL_RET(__NR_fork, ret);\n  return ret;\n#elif defined(__NR_clone3)\n  struct clone_args cl_args = {\n    .exit_signal = SIGCHLD,\n  };\n  return _clone3(&cl_args, sizeof(cl_args));\n#else\n  assert(!\"TODO\");\n#endif\n}\n#endif\n\n#include \"unistd.h\"\n#include \"errno.h\"\n#include \"stdlib.h\"  // malloc\n\n#if defined(__WASM)\nextern int _getcwd(char *, size_t);\n\n#elif defined(__linux__)\n#include \"_syscall.h\"\n\nstatic int _getcwd(char *buffer, size_t size) {\n  int ret;\n  SYSCALL_RET(__NR_getcwd, ret);\n  return ret;\n}\n#endif\n\nchar *getcwd(char *buffer, size_t size) {\n  void *allocated = NULL;\n  if (buffer == NULL) {\n    if (size == 0) {\n      size = 512;  // PATH_MAX\n    }\n    buffer = allocated = malloc(size + 1);\n    if (buffer == NULL)\n      return NULL;\n  }\n  int result = _getcwd(buffer, size);\n  if (result < 0) {\n    errno = -result;\n    free(allocated);\n    return NULL;\n  }\n  return buffer;\n}\n\n#if !defined(__WASM)\n#include \"sys/random.h\"\n#include \"fcntl.h\"  // open\n#include \"unistd.h\"  // close\n\nssize_t getrandom(void *buf, size_t buflen, unsigned int flags) {\n  ssize_t size = 0;\n  int fd = open(flags & GRND_RANDOM ? \"/dev/random\" : \"/dev/urandom\", O_RDONLY);\n  if (fd != 1) {\n    uint64_t r;\n    size = read(fd, buf, buflen);\n    close(fd);\n  }\n  return size;\n}\n#endif\n\n#if !defined(__WASM)\n#include \"unistd.h\"\n#include \"_syscall.h\"\n#include \"assert.h\"\n\nint ioctl(int fd, int request, ...) {\n#if defined(__aarch64__)\n  assert(!\"TODO\");\n#else\n  int ret;\n  SYSCALL_RET(__NR_ioctl, ret);\n  return ret;\n#endif\n}\n#endif\n\n#if !defined(__WASM)\n#include \"unistd.h\"\n#include \"sys/ioctl.h\"  // termio\n\nint isatty(int fd) {\n  struct termio tm;\n  return ioctl(fd, TCGETA, &tm) == 0 ? 1 : 0;\n}\n#endif\n\n#if !defined(__WASM)\n#include \"unistd.h\"\n#include \"_syscall.h\"\n\nint kill(pid_t pid, int sig) {\n  int ret;\n  SYSCALL_RET(__NR_kill, ret);\n  return ret;\n}\n#endif\n\n#if !defined(__WASM)\n#include \"unistd.h\"\n#include \"_syscall.h\"\n\noff_t lseek(int fd, off_t offset, int whence) {\n  off_t ret;\n  SYSCALL_RET(__NR_lseek, ret);\n  return ret;\n}\n#endif\n\n#if !defined(__WASM)\n#include \"fcntl.h\"\n#include \"unistd.h\"\n#include \"errno.h\"\n#include \"_syscall.h\"\n#include \"assert.h\"\n\nint open(const char *fn, int flag, ...) {\n#if defined(__x86_64__)\n  int ret;\n  SYSCALL_RET(__NR_open, ret);\n  if (ret < 0) {\n    errno = -ret;\n    ret = -1;\n  }\n  return ret;\n\n#elif defined(__aarch64__)\n#define STR(x)   STR2(x)\n#define STR2(x)  #x\n\n  int ret;\n  __asm(\"mov w3, w2\\n\"\n\t\"mov w2, w1\\n\"\n\t\"mov x1, x0\\n\"\n\t\"mov w0, #\" STR(AT_FDCWD) \"\\n\");\n  SYSCALL_RET(__NR_openat, ret);\n  if (ret < 0) {\n    errno = -ret;\n    ret = -1;\n  }\n  return ret;\n\n#else\n#error unknown target\n#endif\n}\n#endif\n\n#if !defined(__WASM)\n#include \"unistd.h\"\n#include \"_syscall.h\"\n#include \"assert.h\"\n#include \"errno.h\"\n\n#if defined(__NR_pipe2)\nint pipe2(int *pipefd, int flag) {\n  int ret;\n  SYSCALL_RET(__NR_pipe2, ret);\n  if (ret < 0) {\n    errno = -ret;\n    ret = -1;\n  }\n  return ret;\n}\n#endif\n\nint pipe(int *pipefd) {\n#if defined(__NR_pipe)\n  int ret;\n  SYSCALL_RET(__NR_pipe, ret);\n  if (ret < 0) {\n    errno = -ret;\n    ret = -1;\n  }\n  return ret;\n#elif defined(__NR_pipe2)\n  return pipe2(pipefd, 0);\n#else\n  assert(!\"TODO\");\n#endif\n}\n#endif\n\n#if !defined(__WASM)\n#include \"unistd.h\"\n#include \"_syscall.h\"\n\nssize_t read(int fd, void *buf, size_t size) {\n  ssize_t ret;\n  SYSCALL_RET(__NR_read, ret);\n  return ret;\n}\n#endif\n\n#if !defined(__WASM)\n#include \"unistd.h\"\n#include \"_syscall.h\"\n#include \"fcntl.h\"\n#include \"assert.h\"\n\n#if defined(__NR_unlinkat)\nint unlinkat(int dirfd, const char *pathname, int flags) {\n  int ret;\n  SYSCALL_RET(__NR_unlinkat, ret);\n  return ret;\n}\n#endif\n\nint unlink(const char *pathname) {\n#if defined(__NR_unlink)\n  int ret;\n  SYSCALL_RET(__NR_unlink, ret);\n  return ret;\n#elif defined(__NR_unlinkat)\n  return unlinkat(AT_FDCWD, pathname, 0);\n#else\n  assert(!\"TODO\");\n#endif\n}\n#endif\n\n#if !defined(__WASM)\n#include \"sys/wait.h\"\n#include \"_syscall.h\"\n#include \"errno.h\"\n\npid_t wait4(pid_t pid, int* status, int options, struct rusage *usage) {\n  int ret;\n#if defined(__x86_64__)\n  __asm(\"mov %rcx, %r10\");  // 4th parameter for syscall is `%r10`. `%r10` is caller save so no need to save/restore\n#endif\n  SYSCALL_RET(__NR_wait4, ret);\n  if (ret < 0) {\n    errno = -ret;\n    ret = -1;\n  }\n  return ret;\n}\n#endif\n\n#if !defined(__WASM)\n#include \"unistd.h\"\n#include \"sys/wait.h\"\n\npid_t waitpid(pid_t pid, int *status, int options) {\n  return wait4(pid, status, options, NULL);\n}\n#endif\n\n#include \"unistd.h\"\n\n#if defined(__XV6)\nssize_t write(int fd, const void *str, size_t len) {\n  __asm(\"mov $16, %eax\\n\"  // SYS_write\n        \"int $64\");\n}\n\n#elif defined(__WASM)\n\n#elif defined(__linux__)\n#include \"_syscall.h\"\n\nssize_t write(int fd, const void *str, size_t len) {\n  ssize_t ret;\n  SYSCALL_RET(__NR_write, ret);\n  return ret;\n}\n\n#elif defined(__APPLE__)\n\n// Use libc.\n#define USE_LIBC\n\n#else\n#error Target not supported\n#endif\n"}}}
